import { TestCase, APIEndpoint, CodeChange, TestSuiteEvolution, TestChange, Assertion } from './types';
import { OpenAI } from 'openai';
import * as fs from 'fs';
import * as path from 'path';

export class TestEvolver {
  private testCases: Map<string, TestCase> = new Map();
  private openai: OpenAI | null = null;
  private evolutionHistory: TestSuiteEvolution[] = [];

  constructor(private openaiApiKey?: string) {
    if (openaiApiKey) {
      this.openai = new OpenAI({ apiKey: openaiApiKey });
    }
  }

  async evolveTestSuite(changes: CodeChange[], currentCoverage: number, targetCoverage: number): Promise<TestSuiteEvolution> {
    const evolution: TestSuiteEvolution = {
      version: this.generateVersion(),
      timestamp: new Date(),
      changes: [],
      coverage: {
        before: currentCoverage,
        after: currentCoverage
      },
      reason: this.generateEvolutionReason(changes)
    };

    // Process each change
    for (const change of changes) {
      const testChanges = await this.processCodeChange(change);
      evolution.changes.push(...testChanges);
    }

    // Generate new tests for uncovered code
    if (currentCoverage < targetCoverage) {
      const newTests = await this.generateTestsForCoverage(changes, targetCoverage);
      evolution.changes.push(...newTests);
    }

    // Remove obsolete tests
    const obsoleteTests = this.identifyObsoleteTests(changes);
    evolution.changes.push(...obsoleteTests);

    // Calculate new coverage (simplified)
    evolution.coverage.after = Math.min(
      targetCoverage,
      currentCoverage + (evolution.changes.filter(c => c.type === 'added').length * 5)
    );

    this.evolutionHistory.push(evolution);
    return evolution;
  }

  private async processCodeChange(change: CodeChange): Promise<TestChange[]> {
    const testChanges: TestChange[] = [];

    for (const ch of change.changes) {
      switch (ch.type) {
        case 'endpoint':
          if (ch.after && !ch.before) {
            // New endpoint - generate test
            const test = await this.generateTestForEndpoint(ch.after);
            testChanges.push({
              type: 'added',
              testId: test.id,
              reason: `New endpoint detected: ${ch.path}`,
              details: test
            });
          } else if (!ch.after && ch.before) {
            // Removed endpoint - mark tests as obsolete
            const obsoleteTest = this.findTestForEndpoint(ch.before);
            if (obsoleteTest) {
              testChanges.push({
                type: 'removed',
                testId: obsoleteTest.id,
                reason: `Endpoint removed: ${ch.path}`
              });
            }
          } else if (ch.after && ch.before) {
            // Modified endpoint - update test
            const existingTest = this.findTestForEndpoint(ch.before);
            if (existingTest) {
              const updatedTest = await this.updateTestForEndpoint(existingTest, ch.after);
              testChanges.push({
                type: 'updated',
                testId: updatedTest.id,
                reason: `Endpoint modified: ${ch.path}`,
                details: updatedTest
              });
            }
          }
          break;

        case 'schema':
        case 'validation':
          // Update related tests
          const affectedTests = this.findTestsAffectedByChange(ch);
          for (const test of affectedTests) {
            const updatedTest = await this.updateTestForChange(test, ch);
            testChanges.push({
              type: 'updated',
              testId: updatedTest.id,
              reason: `${ch.type} change detected in ${ch.path}`,
              details: updatedTest
            });
          }
          break;
      }
    }

    return testChanges;
  }

  private async generateTestForEndpoint(endpoint: APIEndpoint): Promise<TestCase> {
    const testId = this.generateTestId(endpoint);
    
    let testCase: TestCase = {
      id: testId,
      name: `Test ${endpoint.method} ${endpoint.path}`,
      endpoint,
      input: this.generateTestInput(endpoint),
      expectedOutput: this.generateExpectedOutput(endpoint),
      assertions: this.generateAssertions(endpoint),
      coverage: {
        lines: [],
        branches: [],
        functions: []
      },
      lastUpdated: new Date(),
      autoGenerated: true
    };

    // Use AI to enhance test if available
    if (this.openai) {
      testCase = await this.enhanceTestWithAI(testCase);
    }

    this.testCases.set(testId, testCase);
    return testCase;
  }

  private async enhanceTestWithAI(testCase: TestCase): Promise<TestCase> {
    if (!this.openai) return testCase;

    try {
      const prompt = `Enhance this API test case:
Endpoint: ${testCase.endpoint.method} ${testCase.endpoint.path}
Current test: ${JSON.stringify(testCase, null, 2)}

Suggest:
1. Additional test inputs for edge cases
2. More comprehensive assertions
3. Performance benchmarks
4. Security test scenarios

Return enhanced test case as JSON.`;

      const completion = await this.openai.chat.completions.create({
        model: "gpt-3.5-turbo",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 1000
      });

      const enhanced = JSON.parse(completion.choices[0]?.message?.content || '{}');
      return { ...testCase, ...enhanced };
    } catch (error) {
      console.error('AI enhancement failed:', error);
      return testCase;
    }
  }

  private generateTestInput(endpoint: APIEndpoint): any {
    const input: any = {};

    // Generate path parameters
    const pathParams = endpoint.path.match(/{([^}]+)}/g);
    if (pathParams) {
      input.params = {};
      pathParams.forEach(param => {
        const paramName = param.slice(1, -1);
        input.params[paramName] = this.generateValueForParam(paramName);
      });
    }

    // Generate body based on method
    if (['POST', 'PUT', 'PATCH'].includes(endpoint.method)) {
      input.body = this.generateRequestBody(endpoint);
    }

    // Add common query parameters
    if (endpoint.method === 'GET') {
      input.query = {
        limit: 10,
        offset: 0
      };
    }

    return input;
  }

  private generateValueForParam(paramName: string): any {
    // Smart parameter value generation based on name
    if (paramName.toLowerCase().includes('id')) return '123';
    if (paramName.toLowerCase().includes('email')) return 'test@example.com';
    if (paramName.toLowerCase().includes('name')) return 'Test Name';
    if (paramName.toLowerCase().includes('date')) return new Date().toISOString();
    if (paramName.toLowerCase().includes('phone')) return '+1234567890';
    if (paramName.toLowerCase().includes('age')) return 25;
    return 'test-value';
  }

  private generateRequestBody(endpoint: APIEndpoint): any {
    // Generate based on endpoint path
    if (endpoint.path.includes('user')) {
      return {
        name: 'Test User',
        email: 'test@example.com',
        password: 'Test123!',
        age: 25
      };
    }
    if (endpoint.path.includes('product')) {
      return {
        name: 'Test Product',
        price: 99.99,
        category: 'Test Category',
        stock: 100
      };
    }
    // Default body
    return {
      name: 'Test Entity',
      value: 'test-value'
    };
  }

  private generateExpectedOutput(endpoint: APIEndpoint): any {
    const statusCodes: { [method: string]: number } = {
      'GET': 200,
      'POST': 201,
      'PUT': 200,
      'PATCH': 200,
      'DELETE': 204
    };

    return {
      status: statusCodes[endpoint.method] || 200,
      headers: {
        'content-type': 'application/json'
      }
    };
  }

  private generateAssertions(endpoint: APIEndpoint): Assertion[] {
    const assertions: Assertion[] = [
      {
        type: 'status',
        expected: this.generateExpectedOutput(endpoint).status
      }
    ];

    // Method-specific assertions
    switch (endpoint.method) {
      case 'GET':
        assertions.push(
          { type: 'schema', expected: 'object', operator: 'equals' },
          { type: 'performance', expected: 200, operator: 'equals' } // ms
        );
        break;
      
      case 'POST':
        assertions.push(
          { type: 'value', path: 'id', expected: 'string', operator: 'exists' },
          { type: 'header', expected: 'location', operator: 'exists' }
        );
        break;
      
      case 'DELETE':
        assertions.push(
          { type: 'value', path: 'body', expected: undefined, operator: 'equals' }
        );
        break;
    }

    return assertions;
  }

  private async updateTestForEndpoint(test: TestCase, endpoint: APIEndpoint): Promise<TestCase> {
    const updatedTest = { ...test };
    updatedTest.endpoint = endpoint;
    updatedTest.lastUpdated = new Date();

    // Regenerate input if path changed
    if (test.endpoint.path !== endpoint.path) {
      updatedTest.input = this.generateTestInput(endpoint);
    }

    // Update assertions if method changed
    if (test.endpoint.method !== endpoint.method) {
      updatedTest.assertions = this.generateAssertions(endpoint);
      updatedTest.expectedOutput = this.generateExpectedOutput(endpoint);
    }

    this.testCases.set(test.id, updatedTest);
    return updatedTest;
  }

  private async generateTestsForCoverage(changes: CodeChange[], targetCoverage: number): Promise<TestChange[]> {
    const newTests: TestChange[] = [];
    
    // Analyze uncovered endpoints
    for (const change of changes) {
      for (const ch of change.changes) {
        if (ch.type === 'endpoint' && ch.after && !this.hasTestForEndpoint(ch.after)) {
          const test = await this.generateTestForEndpoint(ch.after);
          newTests.push({
            type: 'added',
            testId: test.id,
            reason: `Increasing coverage for ${ch.path}`,
            details: test
          });
        }
      }
    }

    return newTests;
  }

  private identifyObsoleteTests(changes: CodeChange[]): TestChange[] {
    const obsoleteTests: TestChange[] = [];
    
    // Check each test against current endpoints
    this.testCases.forEach(test => {
      if (test.isObsolete) {
        obsoleteTests.push({
          type: 'removed',
          testId: test.id,
          reason: 'Test marked as obsolete'
        });
      }
    });

    return obsoleteTests;
  }

  private findTestForEndpoint(endpoint: APIEndpoint): TestCase | undefined {
    return Array.from(this.testCases.values()).find(
      test => test.endpoint.path === endpoint.path && test.endpoint.method === endpoint.method
    );
  }

  private hasTestForEndpoint(endpoint: APIEndpoint): boolean {
    return this.findTestForEndpoint(endpoint) !== undefined;
  }

  private findTestsAffectedByChange(change: any): TestCase[] {
    // Find tests that might be affected by schema or validation changes
    return Array.from(this.testCases.values()).filter(test => {
      return test.endpoint.path.includes(change.path.split('/')[0]);
    });
  }

  private async updateTestForChange(test: TestCase, change: any): Promise<TestCase> {
    const updatedTest = { ...test };
    updatedTest.lastUpdated = new Date();
    
    // Update test based on change type
    if (change.type === 'schema') {
      // Update expected schema in assertions
      updatedTest.assertions = updatedTest.assertions.map(assertion => {
        if (assertion.type === 'schema') {
          return { ...assertion, expected: change.after };
        }
        return assertion;
      });
    }

    this.testCases.set(test.id, updatedTest);
    return updatedTest;
  }

  private generateTestId(endpoint: APIEndpoint): string {
    return `test_${endpoint.method.toLowerCase()}_${endpoint.path.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`;
  }

  private generateVersion(): string {
    const date = new Date();
    return `${date.getFullYear()}.${date.getMonth() + 1}.${date.getDate()}.${this.evolutionHistory.length + 1}`;
  }

  private generateEvolutionReason(changes: CodeChange[]): string {
    const summary = changes.map(change => {
      const changeCount = change.changes.length;
      return `${changeCount} changes in ${path.basename(change.file)}`;
    }).join(', ');
    
    return `Evolving test suite due to: ${summary}`;
  }

  exportTests(outputPath: string): void {
    const tests = Array.from(this.testCases.values());
    fs.writeFileSync(outputPath, JSON.stringify(tests, null, 2));
  }

  importTests(inputPath: string): void {
    const tests = JSON.parse(fs.readFileSync(inputPath, 'utf-8'));
    tests.forEach(test => {
      this.testCases.set(test.id, test);
    });
  }

  getEvolutionHistory(): TestSuiteEvolution[] {
    return this.evolutionHistory;
  }

  getTestCases(): TestCase[] {
    return Array.from(this.testCases.values());
  }
}