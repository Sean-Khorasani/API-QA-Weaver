import { SelfEvolvingTestSuite, EvolutionConfig } from '../src';
import * as fs from 'fs';
import * as path from 'path';

// Mock fs and chokidar
jest.mock('fs');
jest.mock('chokidar');

describe('SelfEvolvingTestSuite', () => {
  let sets: SelfEvolvingTestSuite;
  let config: EvolutionConfig;
  let mockFs: jest.Mocked<typeof fs>;

  beforeEach(() => {
    mockFs = fs as jest.Mocked<typeof fs>;
    
    config = {
      watchPaths: ['/test/src'],
      testPaths: ['/test/tests'],
      updateThreshold: 10,
      coverageTarget: 80,
      aiEnabled: false,
      gitEnabled: false
    };

    // Mock file system operations
    mockFs.existsSync.mockReturnValue(true);
    mockFs.readFileSync.mockReturnValue('test content');
    mockFs.readdirSync.mockReturnValue([]);
    mockFs.mkdirSync.mockReturnValue(undefined);
    mockFs.writeFileSync.mockReturnValue(undefined);

    sets = new SelfEvolvingTestSuite(config);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('initialization', () => {
    it('should initialize successfully', async () => {
      await expect(sets.initialize()).resolves.not.toThrow();
    });

    it('should analyze existing code on initialization', async () => {
      mockFs.readdirSync.mockReturnValue([
        { name: 'api.js', isDirectory: () => false, isFile: () => true } as any
      ]);

      await sets.initialize();
      
      // Verify directory was analyzed
      expect(mockFs.readdirSync).toHaveBeenCalledWith(
        config.watchPaths[0],
        expect.any(Object)
      );
    });
  });

  describe('metrics', () => {
    it('should return initial metrics', () => {
      const metrics = sets.getMetrics();
      
      expect(metrics).toHaveProperty('totalTests');
      expect(metrics).toHaveProperty('autoGeneratedTests');
      expect(metrics).toHaveProperty('coverage');
      expect(metrics).toHaveProperty('lastEvolution');
      expect(metrics.totalTests).toBe(0);
      expect(metrics.lastEvolution).toBeNull();
    });
  });

  describe('stop', () => {
    it('should stop watching without errors', () => {
      expect(() => sets.stop()).not.toThrow();
    });
  });
});